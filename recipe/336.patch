From 166b9f0789556fcbca7872ac0efdb482ac799f78 Mon Sep 17 00:00:00 2001
From: Robin Andersson <robin.andersson@modelon.com>
Date: Thu, 10 Jul 2025 13:20:34 -0400
Subject: [PATCH 1/4] Added changes to how to handle dynamic lib of FMIL in
 particular on linux

---
 setup.py | 70 ++++++++++++++++++++++++++++++++++----------------------
 1 file changed, 43 insertions(+), 27 deletions(-)

diff --git a/setup.py b/setup.py
index 92c0af77..1abe4370 100644
--- a/setup.py
+++ b/setup.py
@@ -111,6 +111,8 @@
 flag_32bit = "-m32"
 extra_c_flags = ""
 
+is_windows = sys.platform.startswith("win")
+
 # Fix path sep
 for x in sys.argv[1:]:
     if not x.find('--prefix'):
@@ -169,29 +171,37 @@
         " specify it using the environment variable FMIL_HOME."
     )
 
+def find_dynamic_fmil_library():
+    """
+        Check to see if FMILIB_SHARED exists and if so copy it, otherwise raise exception.
+    """
+    dirs_to_search = libdirs + bindirs
+    for path_to_dir in dirs_to_search:
+        path_to_dir = os.path.abspath(path_to_dir)
+
+        if not os.path.exists(path_to_dir):
+            continue
+
+        for file_name in os.listdir(path_to_dir):
+            full_path = os.path.join(path_to_dir, file_name)
+            if fmil_name in file_name and not file_name.endswith(".a"):
+                return shutil.copy2(full_path, os.path.join(".", "src", "pyfmi"))
+    raise Exception(
+        f"Could not find shared library '{fmil_name}' at either location:" + \
+            f"\n\t{', '.join(dirs_to_search)}")
+
 if 0 != sys.argv[1].find("clean"): #Dont check if we are cleaning!
 
-    #Check to see if FMILIB_SHARED exists and if so copy it, otherwise raise exception
-    if sys.platform.startswith("win"):
-        dirs_to_search = libdirs + bindirs
-        while dirs_to_search:
-            path_to_dir = os.path.abspath(dirs_to_search.pop())
-            for file_name in os.listdir(path_to_dir):
-                full_path = os.path.join(path_to_dir, file_name)
-                if "fmilib_shared" in file_name and not file_name.endswith(".a"):
-                    fmilib_shared = shutil.copy2(full_path, os.path.join(".", "src", "pyfmi"))
-                    dirs_to_search = None
-                    break
-        if not fmilib_shared:
-            raise Exception(
-                f"Could not find shared library 'fmilib_shared' at either location:" + \
-                    f"\n\t{', '.join(dirs_to_search)}")
-
-        if copy_gcc_lib:
-            path_gcc_lib = ctypes.util.find_library("libgcc_s_dw2-1.dll")
-            if path_gcc_lib is not None:
-                shutil.copy2(path_gcc_lib,os.path.join(".","src","pyfmi"))
-                gcc_lib = os.path.join(".","src","pyfmi","libgcc_s_dw2-1.dll")
+    use_dynamic_fmil_library = fmil_name.endswith("shared")
+
+    if use_dynamic_fmil_library:
+        fmil_shared = find_dynamic_fmil_library()
+
+    if is_windows and copy_gcc_lib:
+        path_gcc_lib = ctypes.util.find_library("libgcc_s_dw2-1.dll")
+        if path_gcc_lib is not None:
+            shutil.copy2(path_gcc_lib,os.path.join(".", "src", "pyfmi"))
+            gcc_lib = os.path.join(".", "src", "pyfmi", "libgcc_s_dw2-1.dll")
 
 if no_msvcr:
     # prevent the MSVCR* being added to the DLLs passed to the linker
@@ -279,7 +289,7 @@ def check_extensions():
                     include_path = incl_path,
                     compile_time_env=compile_time_env,
                     compiler_directives={'language_level' : "3str"})
-    
+
     # UTILITIES
     ext_list += cythonize([os.path.join("src", "pyfmi", "util.pyx")],
                     include_path = incl_path,
@@ -290,6 +300,12 @@ def check_extensions():
                     include_path = incl_path,
                     compiler_directives={'language_level' : "3str"})
 
+    if use_dynamic_fmil_library and (not is_windows):
+        # Since we install the dynamic lib of FMIL into the Package
+        # LD_LIBRARY_PATH is checked first for dynamic lib of FMIL
+        # RPATH is second
+        extra_link_flags += ['-Wl,-rpath,$ORIGIN']
+
     for i in range(len(ext_list)):
 
         ext_list[i].include_dirs = [np.get_include(), "src", os.path.join("src", "pyfmi")] + incdirs
@@ -330,7 +346,7 @@ def check_extensions():
     revision = "unknown"
 version_txt = os.path.join('src', 'pyfmi', 'version.txt')
 
-#If a revision is found, always write it!
+# If a revision is found, always write it!
 if revision != "unknown" and revision!="":
     with open(version_txt, 'w') as f:
         f.write(VERSION+'\n')
@@ -346,8 +362,8 @@ def check_extensions():
     shutil.copy2('CHANGELOG', os.path.join('src', 'pyfmi', 'CHANGELOG'))
 except Exception:
     pass
-extra_package_data = ['*fmilib_shared*'] if sys.platform.startswith("win") else []
-extra_package_data += ['libgcc_s_dw2-1.dll'] if copy_gcc_lib else []
+extra_package_data = [f'*{fmil_name}*']
+extra_package_data += ['libgcc_s_dw2-1.dll'] if is_windows and copy_gcc_lib else []
 
 setup(name=NAME,
       version=VERSION,
@@ -386,9 +402,9 @@ def check_extensions():
       )
 
 
-#Dont forget to delete fmilib_shared
+# Dont forget to delete fmilib_shared
 if 0 != sys.argv[1].find("clean"): #Dont check if we are cleaning!
-    if sys.platform.startswith("win"):
+    if use_dynamic_fmil_library:
         if os.path.exists(fmilib_shared):
             os.remove(fmilib_shared)
         if gcc_lib and os.path.exists(gcc_lib):

From 75bac2fb1022cd3a657383b49548809bd6f481a8 Mon Sep 17 00:00:00 2001
From: Robin Andersson <robin.andersson@modelon.com>
Date: Thu, 10 Jul 2025 13:32:32 -0400
Subject: [PATCH 2/4] Add additional search path

---
 setup.py | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/setup.py b/setup.py
index 1abe4370..fbbf33ca 100644
--- a/setup.py
+++ b/setup.py
@@ -121,7 +121,11 @@
         copy_args[copy_args.index(x)] = x.replace('/',os.sep)
     if not x.find('--fmil-home'):
         incdirs = [os.path.join(x[12:],'include')]
-        libdirs = [os.path.join(x[12:],'lib'), os.path.join(x[12:],'lib64')]
+        libdirs = [
+            os.path.join(x[12:],'lib'),
+            os.path.join(x[12:],'lib64'),
+            os.path.join(x[12:], 'lib', 'x86_64-linux-gnu'),
+        ]
         bindirs = [os.path.join(x[12:],'bin')]
         copy_args.remove(x)
     if not x.find('--fmil-name'):

From a94877599249737b3faab4c5b82c1ff0c6f474e0 Mon Sep 17 00:00:00 2001
From: Robin Andersson <robin.andersson@modelon.com>
Date: Fri, 11 Jul 2025 09:27:30 -0400
Subject: [PATCH 3/4] clean-up, add docs, minor refactoring and fix bug on
 windows

---
 setup.py | 101 ++++++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 73 insertions(+), 28 deletions(-)

diff --git a/setup.py b/setup.py
index fbbf33ca..bf8a0fb0 100644
--- a/setup.py
+++ b/setup.py
@@ -28,7 +28,6 @@
     from setuptools import setup
     have_nd = False
 
-from Cython.Distutils import build_ext
 from Cython.Build import cythonize
 
 
@@ -82,6 +81,52 @@
 
 python setup.py install --fmil-home=/path/to/FMI_Library/
 
+
+Dynamic FMI Library Handling in PyFMI Build Process
+===================================================
+
+PyFMI depends on the FMI Library (FMIL) for core functionality. Users can choose
+between static or dynamic linking via the --fmil-name build argument (default: 'fmilib_shared').
+
+When building with dynamic FMIL, the behavior varies by platform and build type:
+
+Platform-Specific Dynamic Library Handling:
+-------------------------------------------
+
+**Windows Builds:**
+- Dynamic FMIL library (.dll) is automatically copied into the PyFMI package directory
+- Creates a self-contained installation with no external library dependencies
+- End users don't need separate FMIL installation or PATH configuration
+
+**Linux Standard Installation:**
+- PyFMI extensions are linked with RPATH pointing to original FMIL location
+- Dynamic library remains in its system installation directory
+- Requires FMIL to remain accessible at the configured path during runtime
+- Suitable for system-wide installations with centralized FMIL management
+- Smaller PyFMI package size due to external library reference
+
+**Linux Wheel Builds:**
+- Dynamic FMIL library is copied into the PyFMI package (similar to Windows)
+- RPATH set to '$ORIGIN' for relative library loading
+- Creates portable, self-contained wheels for distribution
+- No external FMIL dependency required at runtime
+
+**Static Library Alternative:**
+- When using static FMIL (--fmil-name without 'shared' suffix):
+- Library code is embedded directly into PyFMI extensions
+- Larger package size but completely self-contained
+- No runtime library dependencies
+
+Build Process Flow:
+------------------
+1. Locate FMIL library in specified directories (lib/, lib64/, bin/)
+2. For dynamic libraries on Windows or wheel builds: copy to package directory
+3. Configure appropriate RPATH settings for Linux installations
+4. Build Cython extensions with proper library linking
+5. Clean up temporary library copies after successful build
+
+This approach ensures PyFMI works correctly across different deployment scenarios
+while optimizing for each platform's conventions and user expectations.
 """
 
 copy_args = sys.argv[1:]
@@ -112,7 +157,7 @@
 extra_c_flags = ""
 
 is_windows = sys.platform.startswith("win")
-
+is_wheel_build = 'bdist_wheel' in sys.argv
 # Fix path sep
 for x in sys.argv[1:]:
     if not x.find('--prefix'):
@@ -136,11 +181,7 @@
             copy_gcc_lib = True
         copy_args.remove(x)
     if not x.find('--static'):
-        static = x[9:]
-        if x[9:].upper() == "TRUE":
-            static = True
-        else:
-            static = False
+        static = x[9:].upper() == "TRUE"
         copy_args.remove(x)
     if not x.find('--force-32bit'):
         if x[14:].upper() == "TRUE":
@@ -176,9 +217,7 @@
     )
 
 def find_dynamic_fmil_library():
-    """
-        Check to see if FMILIB_SHARED exists and if so copy it, otherwise raise exception.
-    """
+    """ Find the dynamic library of FMIL. """
     dirs_to_search = libdirs + bindirs
     for path_to_dir in dirs_to_search:
         path_to_dir = os.path.abspath(path_to_dir)
@@ -189,23 +228,30 @@ def find_dynamic_fmil_library():
         for file_name in os.listdir(path_to_dir):
             full_path = os.path.join(path_to_dir, file_name)
             if fmil_name in file_name and not file_name.endswith(".a"):
-                return shutil.copy2(full_path, os.path.join(".", "src", "pyfmi"))
+                return full_path
+
     raise Exception(
         f"Could not find shared library '{fmil_name}' at either location:" + \
             f"\n\t{', '.join(dirs_to_search)}")
 
-if 0 != sys.argv[1].find("clean"): #Dont check if we are cleaning!
+if 0 != sys.argv[1].find("clean"): # Dont check if we are cleaning!
 
-    use_dynamic_fmil_library = fmil_name.endswith("shared")
+    use_dynamic_fmil_library = fmil_name.endswith("shared") # this should be improved in a future release
 
+    remove_copied_fmil = False
     if use_dynamic_fmil_library:
         fmil_shared = find_dynamic_fmil_library()
 
+        if is_windows or is_wheel_build:
+            # Copy the fmil library to current directory
+            shutil.copy2(fmil_shared, os.path.join(".", "src", "pyfmi"))
+            remove_copied_fmil = True
+
+
     if is_windows and copy_gcc_lib:
         path_gcc_lib = ctypes.util.find_library("libgcc_s_dw2-1.dll")
         if path_gcc_lib is not None:
-            shutil.copy2(path_gcc_lib,os.path.join(".", "src", "pyfmi"))
-            gcc_lib = os.path.join(".", "src", "pyfmi", "libgcc_s_dw2-1.dll")
+            gcc_lib = shutil.copy2(path_gcc_lib,os.path.join(".", "src", "pyfmi"))
 
 if no_msvcr:
     # prevent the MSVCR* being added to the DLLs passed to the linker
@@ -304,11 +350,13 @@ def check_extensions():
                     include_path = incl_path,
                     compiler_directives={'language_level' : "3str"})
 
-    if use_dynamic_fmil_library and (not is_windows):
-        # Since we install the dynamic lib of FMIL into the Package
-        # LD_LIBRARY_PATH is checked first for dynamic lib of FMIL
-        # RPATH is second
-        extra_link_flags += ['-Wl,-rpath,$ORIGIN']
+    if not is_windows:
+        if use_dynamic_fmil_library:
+            if is_wheel_build:
+                extra_link_flags += ['-Wl,-rpath,$ORIGIN']
+            else:
+                extra_link_flags += [f'-Wl,-rpath,{os.path.dirname(fmil_shared)}']
+
 
     for i in range(len(ext_list)):
 
@@ -405,11 +453,8 @@ def check_extensions():
       script_args=copy_args
       )
 
-
-# Dont forget to delete fmilib_shared
-if 0 != sys.argv[1].find("clean"): #Dont check if we are cleaning!
-    if use_dynamic_fmil_library:
-        if os.path.exists(fmilib_shared):
-            os.remove(fmilib_shared)
-        if gcc_lib and os.path.exists(gcc_lib):
-            os.remove(gcc_lib)
+if 0 != sys.argv[1].find("clean"): # Dont check if we are cleaning!
+    if remove_copied_fmil:
+        os.remove(fmil_shared)
+    if gcc_lib and os.path.exists(gcc_lib):
+        os.remove(gcc_lib)

From 6dce81a06e2462835ab3665fe5e495ddd0483e4f Mon Sep 17 00:00:00 2001
From: Robin Andersson <robin.andersson@modelon.com>
Date: Fri, 11 Jul 2025 09:40:22 -0400
Subject: [PATCH 4/4] remove hardcoded directory name, fix grammar in exception
 message

---
 setup.py | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/setup.py b/setup.py
index bf8a0fb0..142806a8 100644
--- a/setup.py
+++ b/setup.py
@@ -17,6 +17,7 @@
 
 import os
 import shutil
+import sysconfig
 import numpy as np
 import ctypes.util
 import sys
@@ -169,7 +170,7 @@
         libdirs = [
             os.path.join(x[12:],'lib'),
             os.path.join(x[12:],'lib64'),
-            os.path.join(x[12:], 'lib', 'x86_64-linux-gnu'),
+            os.path.join(x[12:], 'lib', sysconfig.get_config_var('MULTIARCH')),
         ]
         bindirs = [os.path.join(x[12:],'bin')]
         copy_args.remove(x)
@@ -231,7 +232,7 @@ def find_dynamic_fmil_library():
                 return full_path
 
     raise Exception(
-        f"Could not find shared library '{fmil_name}' at either location:" + \
+        f"Could not find shared library '{fmil_name}' at either locations:" + \
             f"\n\t{', '.join(dirs_to_search)}")
 
 if 0 != sys.argv[1].find("clean"): # Dont check if we are cleaning!
